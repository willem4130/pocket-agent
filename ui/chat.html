<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src 'self' data:;">
  <title>Pocket Agent</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;700&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a0a0b;
      --bg-secondary: #141415;
      --bg-tertiary: #1c1c1e;
      --border: #2a2a2d;
      --text-primary: #fafafa;
      --text-secondary: #a1a1a6;
      --text-muted: #636366;
      --accent: #a855f7;
      --accent-secondary: #ec4899;
      --accent-hover: #c084fc;
      --user-bubble: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
      --user-bubble-solid: #a855f7;
      --assistant-bubble: #1c1c1e;
      --error: #ef4444;
      --success: #22c55e;
      --radius: 20px;
      --radius-sm: 10px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Sora', -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
    }

    /* Header */
    header {
      background: var(--bg-secondary);
      padding: 10px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      position: relative;
    }

    /* Session Tabs */
    .tabs-container {
      display: flex;
      align-items: center;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
      gap: 4px;
      overflow-x: auto;
      flex-shrink: 0;
    }

    .tabs-container::-webkit-scrollbar {
      height: 0;
    }

    .tab {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-bottom: none;
      color: var(--text-secondary);
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 12px;
      font-weight: 400;
      cursor: grab;
      border-radius: 8px 8px 0 0;
      transition: background 0.15s ease, color 0.15s ease, transform 0.15s ease, opacity 0.15s ease, border-color 0.15s ease;
      white-space: nowrap;
      max-width: 180px;
      position: relative;
      user-select: none;
      margin-bottom: -1px;
    }

    .tab:hover {
      color: var(--text-primary);
      background: var(--bg-secondary);
      border-color: var(--text-muted);
    }

    .tab.active {
      color: var(--text-primary);
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-bottom: 1px solid var(--bg-primary);
    }

    .tab.dragging {
      opacity: 0.6;
      cursor: grabbing;
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .tab.dragging .tab-close {
      color: rgba(255,255,255,0.7);
    }

    .tab.loading .tab-name {
      background: linear-gradient(
        90deg,
        var(--text-primary) 0%,
        var(--text-primary) 40%,
        #60a5fa 50%,
        var(--text-primary) 60%,
        var(--text-primary) 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: tab-text-shimmer 1.5s ease-in-out infinite;
    }

    @keyframes tab-text-shimmer {
      0% { background-position: 100% 0; }
      100% { background-position: -100% 0; }
    }

    .tab-name {
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
    }

    .tab-name-input {
      background: transparent;
      border: 1px solid var(--accent);
      border-radius: 4px;
      color: var(--text-primary);
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 12px;
      font-weight: 400;
      padding: 2px 6px;
      width: 100px;
      outline: none;
    }

    .tab-close {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 4px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0;
      line-height: 1;
      font-size: 14px;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .tab-close:hover {
      background: var(--error);
      color: white;
    }

    .tab-telegram-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0088cc;
      flex-shrink: 0;
      margin-left: 2px;
    }

    .tab-telegram-icon svg {
      width: 12px;
      height: 12px;
    }

    .new-tab-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      background: transparent;
      border: 1px dashed var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
      transition: all 0.15s ease;
      margin-left: 8px;
      flex-shrink: 0;
    }

    .new-tab-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .header-logo {
      width: 20px;
      height: 20px;
      object-fit: contain;
      filter: invert(1) brightness(2);
      image-rendering: -webkit-optimize-contrast;
    }

    header h1 {
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0;
      background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      display: flex;
      align-items: center;
      margin: 0;
    }

    .version-badge {
      font-size: 9px;
      font-weight: 600;
      color: #ffffff;
      background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 6px;
      letter-spacing: 0;
      -webkit-text-fill-color: #ffffff;
    }

    .model-badge {
      font-size: 9px;
      font-weight: 600;
      color: #ffffff;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      padding: 2px 8px;
      border-radius: 4px;
      margin-left: 8px;
      letter-spacing: 0;
      -webkit-text-fill-color: #ffffff;
    }

    .update-badge {
      font-size: 9px;
      font-weight: 600;
      color: #ffffff;
      background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
      padding: 2px 8px;
      border-radius: 4px;
      margin-left: 8px;
      letter-spacing: 0;
      -webkit-text-fill-color: #ffffff;
      cursor: pointer;
      display: none;
      animation: pulse-update 2s ease-in-out infinite;
    }

    .update-badge:hover {
      background: linear-gradient(135deg, #fb923c 0%, #f97316 100%);
    }

    @keyframes pulse-update {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .stats {
      font-size: 10px;
      color: var(--text-muted);
      font-weight: 500;
      line-height: 1;
    }

    /* Hamburger Menu */
    .hamburger-menu {
      position: relative;
    }

    .hamburger-btn {
      width: 28px;
      height: 28px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .hamburger-btn:hover {
      background: var(--border);
      transform: scale(1.05);
    }

    .hamburger-btn span {
      display: block;
      width: 14px;
      height: 2px;
      background: var(--text-secondary);
      border-radius: 1px;
      transition: all 0.2s ease;
    }

    .hamburger-btn:hover span {
      background: var(--text-primary);
    }

    .hamburger-btn.active span:nth-child(1) {
      transform: rotate(45deg) translate(4px, 4px);
    }

    .hamburger-btn.active span:nth-child(2) {
      opacity: 0;
    }

    .hamburger-btn.active span:nth-child(3) {
      transform: rotate(-45deg) translate(4px, -4px);
    }

    .menu-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      min-width: 180px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-8px);
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 200;
      overflow: hidden;
    }

    .menu-dropdown.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      background: transparent;
      border: none;
      width: 100%;
      text-align: left;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .menu-item:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .menu-item svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .menu-item.danger:hover {
      color: var(--error);
    }

    .menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    /* About Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.show { display: flex; }

    .modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      width: 90%;
      max-width: 360px;
      overflow: hidden;
      animation: modalIn 0.2s ease;
    }

    @keyframes modalIn {
      from { opacity: 0; transform: scale(0.96); }
      to { opacity: 1; transform: scale(1); }
    }

    .modal-header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      background: var(--bg-secondary);
    }

    .modal-icon {
      width: 40px;
      height: 40px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      flex-shrink: 0;
    }

    .modal-title h2 {
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 15px;
      font-weight: 700;
      margin: 0;
    }

    .modal-title p {
      font-size: 11px;
      color: var(--text-muted);
      margin: 2px 0 0;
    }

    .modal-close {
      margin-left: auto;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-close:hover { color: var(--text-primary); }

    .modal-body {
      padding: 16px;
    }

    .about-content {
      color: var(--text-secondary);
      font-size: 13px;
      line-height: 1.6;
    }

    .about-content p {
      margin: 0 0 12px;
    }

    .about-content p:last-child {
      margin-bottom: 0;
    }

    .about-links {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 16px;
    }

    .about-link {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      text-decoration: none;
      font-size: 13px;
      transition: all 0.15s;
      cursor: pointer;
    }

    .about-link:hover {
      border-color: var(--accent);
      background: rgba(255, 136, 0, 0.1);
    }

    .about-link svg {
      width: 18px;
      height: 18px;
      color: var(--accent);
      flex-shrink: 0;
    }

    .about-link span {
      flex: 1;
    }

    .about-link small {
      color: var(--text-muted);
      font-size: 11px;
    }

    /* Messages Container */
    #messages {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      scroll-behavior: smooth;
    }

    #messages::-webkit-scrollbar {
      width: 6px;
    }

    #messages::-webkit-scrollbar-track {
      background: transparent;
    }

    #messages::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }

    #messages::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    /* Scroll Buttons */
    .scroll-btn {
      position: fixed;
      right: 24px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      z-index: 100;
    }

    .scroll-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
      border-color: var(--text-muted);
    }

    .scroll-btn.visible {
      opacity: 1;
      visibility: visible;
    }

    .scroll-btn svg {
      width: 18px;
      height: 18px;
    }

    #scroll-top-btn {
      top: 100px;
    }

    #scroll-bottom-btn {
      bottom: 140px;
    }

    /* Message Bubbles */
    .message {
      max-width: 80%;
      padding: 12px 16px;
      border-radius: var(--radius);
      line-height: 1.5;
      font-size: 14px;
      word-wrap: break-word;
      animation: messageIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      transform-origin: bottom;
    }

    @keyframes messageIn {
      0% {
        opacity: 0;
        transform: translateY(16px) scale(0.92);
      }
      50% {
        transform: translateY(-4px) scale(1.02);
      }
      75% {
        transform: translateY(2px) scale(0.99);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .message.user {
      align-self: flex-end;
      background: var(--user-bubble);
      color: white;
      border-bottom-right-radius: 6px;
      box-shadow: 0 4px 14px rgba(168, 85, 247, 0.25);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .message.user:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(168, 85, 247, 0.35);
    }

    .message.assistant {
      align-self: flex-start;
      background: var(--assistant-bubble);
      border: 1px solid var(--border);
      border-bottom-left-radius: 6px;
      color: var(--text-primary);
      transition: transform 0.2s ease, border-color 0.2s ease;
    }

    .message.assistant:hover {
      transform: translateY(-1px);
      border-color: var(--text-muted);
    }

    .message.system {
      align-self: center;
      background: transparent;
      color: var(--text-muted);
      font-size: 13px;
      padding: 8px 16px;
    }

    .telegram-header {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: #0088cc;
      margin-bottom: 6px;
      font-weight: 500;
      opacity: 0.9;
    }

    .telegram-header svg {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
    }

    .message.error {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: var(--error);
    }

    /* Queued message state - greyed out until processing */
    .message.queued {
      opacity: 0.5;
      filter: grayscale(30%);
      transition: opacity 0.3s ease, filter 0.3s ease;
    }

    .message.queued::after {
      content: 'queued';
      position: absolute;
      top: -8px;
      right: 8px;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #ffffff;
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .message.user.queued {
      position: relative;
      box-shadow: none;
    }

    .message.user.queued:hover {
      transform: none;
      box-shadow: none;
    }

    /* Scheduled task badge */
    .message.scheduled {
      position: relative;
    }

    .message.scheduled::after {
      content: attr(data-badge);
      position: absolute;
      top: -8px;
      left: 8px;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.3px;
      color: #ffffff;
      background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
      padding: 2px 6px;
      border-radius: 4px;
    }

    /* Telegram message badge */
    .message.from-telegram {
      position: relative;
    }

    .message.from-telegram .telegram-badge {
      position: absolute;
      top: -8px;
      right: 8px;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.3px;
      color: #ffffff;
      background: linear-gradient(135deg, #229ED9 0%, #1a7fb3 100%);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .message.from-telegram .telegram-badge svg {
      width: 10px;
      height: 10px;
      fill: #ffffff;
    }

    /* Queue indicator in status */
    .queue-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      margin-top: 4px;
    }

    .queue-indicator .queue-count {
      background: var(--accent);
      color: white;
      padding: 1px 6px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 10px;
    }

    /* Code blocks in messages */
    .message code {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 13px;
    }

    .message pre {
      background: rgba(0, 0, 0, 0.4);
      padding: 12px;
      border-radius: var(--radius-sm);
      overflow-x: auto;
      margin: 8px 0;
    }

    .message pre code {
      background: none;
      padding: 0;
    }

    /* Markdown elements - tight spacing for chat */
    .message h1, .message h2, .message h3, .message h4 {
      margin: 1em 0 0.4em 0;
      font-weight: 600;
      line-height: 1.3;
    }

    .message h1:first-child, .message h2:first-child,
    .message h3:first-child, .message h4:first-child {
      margin-top: 0;
    }

    .message h1 { font-size: 1.2em; }
    .message h2 { font-size: 1.1em; }
    .message h3 { font-size: 1.05em; }
    .message h4 { font-size: 1em; }

    .message p {
      margin: 0;
    }

    .message p + p {
      margin-top: 0.5em;
    }

    .message > *:last-child {
      margin-bottom: 0 !important;
    }

    .message > *:first-child {
      margin-top: 0 !important;
    }

    .message ul, .message ol {
      margin: 0.3em 0;
      padding-left: 1.4em;
    }

    .message ul:first-child, .message ol:first-child { margin-top: 0; }
    .message ul:last-child, .message ol:last-child { margin-bottom: 0; }

    .message li {
      margin: 0;
      padding: 0;
      line-height: 1.5;
    }

    .message li + li {
      margin-top: 0.1em;
    }

    .message li p,
    .message li > p,
    .message li p:first-child,
    .message li p:last-child {
      margin: 0;
      padding: 0;
      display: inline;
    }

    .message a {
      color: #60a5fa;
      text-decoration: underline;
      text-decoration-color: rgba(96, 165, 250, 0.4);
      text-underline-offset: 2px;
    }

    .message a:hover {
      color: #93c5fd;
      text-decoration-color: rgba(147, 197, 253, 0.6);
    }

    .message.user a {
      color: #bfdbfe;
      text-decoration-color: rgba(191, 219, 254, 0.4);
    }

    .message.user a:hover {
      color: #ffffff;
      text-decoration-color: rgba(255, 255, 255, 0.6);
    }

    .message hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 0.6em 0;
    }

    .message blockquote {
      border-left: 3px solid var(--accent);
      padding-left: 0.8em;
      margin: 0.4em 0;
      color: var(--text-secondary);
    }

    .message .table-wrapper {
      overflow-x: auto;
      margin: 0.5em 0;
      max-width: 100%;
    }

    .message table {
      border-collapse: collapse;
      min-width: 100%;
      font-size: 0.95em;
      white-space: nowrap;
    }

    .message th, .message td {
      border: 1px solid var(--border);
      padding: 0.4em 0.6em;
      text-align: left;
    }

    .message th {
      background: var(--bg-tertiary);
    }

    .message strong { font-weight: 600; }
    .message em { font-style: italic; }

    /* Status Indicator */
    .status-indicator {
      align-self: flex-start;
      padding: 12px 16px;
      background: var(--assistant-bubble);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      border-bottom-left-radius: 6px;
      display: flex;
      align-items: center;
      gap: 12px;
      animation: messageIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      max-width: 80%;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
    }

    .status-spinner {
      width: 24px;
      height: 18px;
      background: transparent;
      flex-shrink: 0;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .status-spinner::before {
      content: '';
      position: absolute;
      width: 3px;
      height: 3px;
      top: 0;
      left: 0;
      animation: pixelcat 0.6s steps(1) infinite;
      image-rendering: pixelated;
    }

    @keyframes pixelcat {
      /* Frame 1: Cat walking - legs apart */
      0%, 25% {
        box-shadow:
          /* Ears */
          3px 0 0 var(--accent), 9px 0 0 var(--accent),
          /* Head */
          3px 3px 0 var(--accent), 6px 3px 0 var(--accent), 9px 3px 0 var(--accent),
          0 6px 0 var(--accent), 3px 6px 0 var(--accent), 6px 6px 0 var(--accent), 9px 6px 0 var(--accent), 12px 6px 0 var(--accent),
          /* Eyes */
          3px 6px 0 #fff, 9px 6px 0 #fff,
          /* Body */
          3px 9px 0 var(--accent), 6px 9px 0 var(--accent), 9px 9px 0 var(--accent), 12px 9px 0 var(--accent), 15px 9px 0 var(--accent),
          3px 12px 0 var(--accent), 6px 12px 0 var(--accent), 9px 12px 0 var(--accent), 12px 12px 0 var(--accent),
          /* Tail up */
          18px 6px 0 var(--accent), 21px 3px 0 var(--accent),
          /* Legs - apart */
          3px 15px 0 var(--accent), 12px 15px 0 var(--accent);
      }
      /* Frame 2: Cat walking - legs together */
      25.01%, 50% {
        box-shadow:
          /* Ears */
          3px 0 0 var(--accent), 9px 0 0 var(--accent),
          /* Head */
          3px 3px 0 var(--accent), 6px 3px 0 var(--accent), 9px 3px 0 var(--accent),
          0 6px 0 var(--accent), 3px 6px 0 var(--accent), 6px 6px 0 var(--accent), 9px 6px 0 var(--accent), 12px 6px 0 var(--accent),
          /* Eyes */
          3px 6px 0 #fff, 9px 6px 0 #fff,
          /* Body */
          3px 9px 0 var(--accent), 6px 9px 0 var(--accent), 9px 9px 0 var(--accent), 12px 9px 0 var(--accent), 15px 9px 0 var(--accent),
          3px 12px 0 var(--accent), 6px 12px 0 var(--accent), 9px 12px 0 var(--accent), 12px 12px 0 var(--accent),
          /* Tail middle */
          18px 9px 0 var(--accent), 21px 6px 0 var(--accent),
          /* Legs - together */
          6px 15px 0 var(--accent), 9px 15px 0 var(--accent);
      }
      /* Frame 3: Cat walking - legs crossed */
      50.01%, 75% {
        box-shadow:
          /* Ears */
          3px 0 0 var(--accent), 9px 0 0 var(--accent),
          /* Head */
          3px 3px 0 var(--accent), 6px 3px 0 var(--accent), 9px 3px 0 var(--accent),
          0 6px 0 var(--accent), 3px 6px 0 var(--accent), 6px 6px 0 var(--accent), 9px 6px 0 var(--accent), 12px 6px 0 var(--accent),
          /* Eyes */
          3px 6px 0 #fff, 9px 6px 0 #fff,
          /* Body */
          3px 9px 0 var(--accent), 6px 9px 0 var(--accent), 9px 9px 0 var(--accent), 12px 9px 0 var(--accent), 15px 9px 0 var(--accent),
          3px 12px 0 var(--accent), 6px 12px 0 var(--accent), 9px 12px 0 var(--accent), 12px 12px 0 var(--accent),
          /* Tail down */
          18px 12px 0 var(--accent), 21px 9px 0 var(--accent),
          /* Legs - reversed */
          12px 15px 0 var(--accent), 3px 15px 0 var(--accent);
      }
      /* Frame 4: Cat walking - legs wide */
      75.01%, 100% {
        box-shadow:
          /* Ears */
          3px 0 0 var(--accent), 9px 0 0 var(--accent),
          /* Head */
          3px 3px 0 var(--accent), 6px 3px 0 var(--accent), 9px 3px 0 var(--accent),
          0 6px 0 var(--accent), 3px 6px 0 var(--accent), 6px 6px 0 var(--accent), 9px 6px 0 var(--accent), 12px 6px 0 var(--accent),
          /* Eyes */
          3px 6px 0 #fff, 9px 6px 0 #fff,
          /* Body */
          3px 9px 0 var(--accent), 6px 9px 0 var(--accent), 9px 9px 0 var(--accent), 12px 9px 0 var(--accent), 15px 9px 0 var(--accent),
          3px 12px 0 var(--accent), 6px 12px 0 var(--accent), 9px 12px 0 var(--accent), 12px 12px 0 var(--accent),
          /* Tail up */
          18px 6px 0 var(--accent), 21px 3px 0 var(--accent),
          /* Legs - wide */
          0 15px 0 var(--accent), 15px 15px 0 var(--accent);
      }
    }

    .status-content {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .status-action {
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 13px;
      font-weight: 400;
      background: linear-gradient(
        90deg,
        var(--text-primary) 0%,
        var(--accent) 20%,
        var(--accent-secondary) 40%,
        var(--accent) 60%,
        var(--text-primary) 80%,
        var(--accent) 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 2s ease-in-out infinite;
    }

    @keyframes shimmer {
      0% { background-position: 100% 0; }
      100% { background-position: -100% 0; }
    }

    /* Subagent active state - purple/pink vibe */
    .status-indicator.subagent-active {
      border-color: #a855f7;
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.1) 0%, rgba(236, 72, 153, 0.1) 100%);
    }

    .status-indicator.subagent-active .status-spinner {
      /* Pixel cat already uses --accent which is purple */
    }

    .status-indicator.subagent-active .status-action {
      background: linear-gradient(
        90deg,
        #a855f7 0%,
        #ec4899 25%,
        #a855f7 50%,
        #ec4899 75%,
        #a855f7 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 1.5s ease-in-out infinite;
    }

    /* Tool blocked state - red/orange warning vibe */
    .status-indicator.tool-blocked {
      border-color: #ef4444;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(249, 115, 22, 0.15) 100%);
      animation: blocked-pulse 0.5s ease-in-out 2;
    }

    .status-indicator.tool-blocked .status-action {
      background: linear-gradient(
        90deg,
        #ef4444 0%,
        #f97316 50%,
        #ef4444 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shimmer 1s ease-in-out infinite;
    }

    .status-indicator.tool-blocked .status-detail {
      color: #f97316;
    }

    @keyframes blocked-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    .status-detail {
      font-size: 12px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    }

    /* Simple typing dots fallback */
    .typing {
      align-self: flex-start;
      padding: 14px 18px;
      background: var(--assistant-bubble);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      border-bottom-left-radius: 6px;
      display: flex;
      gap: 6px;
      animation: messageIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .typing-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      animation: typingBounce 1.4s infinite ease-in-out both;
    }

    .typing-dot:nth-child(1) { animation-delay: -0.32s; background: var(--accent); }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%); }
    .typing-dot:nth-child(3) { animation-delay: 0s; background: var(--accent-secondary); }

    @keyframes typingBounce {
      0%, 80%, 100% {
        transform: scale(0.7) translateY(0);
        opacity: 0.4;
      }
      40% {
        transform: scale(1.1) translateY(-4px);
        opacity: 1;
      }
    }

    /* Input Area */
    #input-area {
      padding: 0 20px 20px 20px;
      background: var(--bg-secondary);
      display: flex;
      gap: 12px;
      align-items: center;
      flex-shrink: 0;
    }

    .input-container {
      flex: 1;
      display: flex;
      align-items: flex-end;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 4px;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }

    .input-container:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.15), 0 0 20px rgba(168, 85, 247, 0.1);
    }

    .attach-btn {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      color: var(--text-muted);
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      flex-shrink: 0;
    }

    .attach-btn:hover {
      background: var(--border);
      color: var(--accent);
      transform: scale(1.1) rotate(-10deg);
    }

    .attach-btn:active {
      transform: scale(0.95) rotate(0deg);
    }

    .attach-btn svg {
      width: 18px;
      height: 18px;
    }

    #message-input {
      flex: 1;
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 14px;
      font-family: inherit;
      outline: none;
      resize: none;
      min-height: 24px;
      max-height: 150px;
      line-height: 1.5;
      position: relative;
      z-index: 1;
    }

    #message-input::placeholder {
      color: var(--text-muted);
    }

    #message-input.has-suggestion::placeholder {
      color: transparent;
    }

    .textarea-wrapper {
      position: relative;
      flex: 1;
      display: flex;
    }

    #ghost-suggestion {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 8px 12px;
      font-size: 14px;
      font-family: inherit;
      line-height: 1.5;
      color: var(--text-muted);
      pointer-events: none;
      white-space: pre-wrap;
      word-wrap: break-word;
      opacity: 0.6;
    }

    #ghost-suggestion .tab-hint {
      color: var(--accent);
      opacity: 0.7;
      font-size: 12px;
      margin-left: 8px;
    }

    #send-btn {
      width: 42px;
      height: 42px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%);
      color: white;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      flex-shrink: 0;
      box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3), inset 0 -3px rgba(0, 0, 0, 0.2);
    }

    #send-btn:hover:not(:disabled) {
      transform: scale(1.08) rotate(-3deg);
      box-shadow: 0 6px 20px rgba(168, 85, 247, 0.45), inset 0 -3px rgba(0, 0, 0, 0.2);
    }

    #send-btn:active:not(:disabled) {
      transform: scale(0.95) rotate(0deg);
    }

    #send-btn:disabled {
      background: var(--bg-tertiary);
      color: var(--text-muted);
      cursor: not-allowed;
      box-shadow: none;
    }

    #send-btn svg {
      width: 18px;
      height: 18px;
      transition: transform 0.2s ease;
    }

    #send-btn:hover:not(:disabled) svg {
      transform: scale(1.1);
    }

    #send-btn.stop-btn {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3), inset 0 -3px rgba(0, 0, 0, 0.2);
    }

    #send-btn.stop-btn:hover {
      background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.45);
      transform: scale(1.08);
    }

    /* Search Area */
    #search-area {
      padding: 10px 20px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    .search-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .search-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .search-toggle svg {
      width: 14px;
      height: 14px;
    }

    #search-area.searching .search-toggle {
      display: none;
    }

    #search-expanded {
      display: none;
      align-items: center;
      gap: 8px;
    }

    #search-area.searching #search-expanded {
      display: flex;
    }

    #search-expanded .search-icon {
      color: var(--text-muted);
      flex-shrink: 0;
    }

    #search-input {
      flex: 1;
      padding: 6px 0;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      outline: none;
      min-width: 0;
    }

    #search-input::placeholder {
      color: var(--text-muted);
    }

    .search-results-count {
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .search-results-count.has-results {
      color: var(--accent);
    }

    .search-nav {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .search-nav-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .search-nav-btn:hover:not(:disabled) {
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .search-nav-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .search-nav-btn svg {
      width: 14px;
      height: 14px;
    }

    .search-close-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .search-close-btn:hover {
      background: var(--error);
      color: white;
    }

    .search-close-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Search highlight */
    mark.search-highlight {
      background: rgba(168, 85, 247, 0.4);
      color: inherit;
      border-radius: 2px;
      padding: 0 2px;
    }

    mark.search-highlight.current {
      background: var(--accent);
      color: white;
    }

    /* Empty State */
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      gap: 16px;
      padding: 40px;
      animation: emptyStateIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes emptyStateIn {
      0% {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
      }
      100% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .empty-state .pixel-heart {
      width: 4px;
      height: 4px;
      margin: 20px auto 30px;
      position: relative;
      left: -14px;
      background: transparent;
      animation: pixelheart-pulse 1.2s ease-in-out infinite;
      image-rendering: pixelated;
      box-shadow:
        /* Row 1 */
        4px 0 0 var(--accent), 8px 0 0 var(--accent),
        20px 0 0 var(--accent-secondary), 24px 0 0 var(--accent-secondary),
        /* Row 2 */
        0 4px 0 var(--accent), 4px 4px 0 var(--accent), 8px 4px 0 var(--accent), 12px 4px 0 var(--accent),
        16px 4px 0 var(--accent-secondary), 20px 4px 0 var(--accent-secondary), 24px 4px 0 var(--accent-secondary), 28px 4px 0 var(--accent-secondary),
        /* Row 3 */
        0 8px 0 var(--accent), 4px 8px 0 var(--accent), 8px 8px 0 var(--accent), 12px 8px 0 #c084fc,
        16px 8px 0 #c084fc, 20px 8px 0 var(--accent-secondary), 24px 8px 0 var(--accent-secondary), 28px 8px 0 var(--accent-secondary),
        /* Row 4 */
        0 12px 0 var(--accent), 4px 12px 0 var(--accent), 8px 12px 0 #c084fc, 12px 12px 0 #c084fc,
        16px 12px 0 #c084fc, 20px 12px 0 #c084fc, 24px 12px 0 var(--accent-secondary), 28px 12px 0 var(--accent-secondary),
        /* Row 5 */
        4px 16px 0 var(--accent), 8px 16px 0 #c084fc, 12px 16px 0 #c084fc,
        16px 16px 0 #c084fc, 20px 16px 0 #c084fc, 24px 16px 0 var(--accent-secondary),
        /* Row 6 */
        8px 20px 0 #c084fc, 12px 20px 0 #c084fc, 16px 20px 0 #c084fc, 20px 20px 0 #c084fc,
        /* Row 7 */
        12px 24px 0 #c084fc, 16px 24px 0 #c084fc,
        /* Row 8 - tip */
        14px 28px 0 #c084fc;
    }

    @keyframes pixelheart-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }

    .empty-state .empty-title {
      font-family: 'Pixelify Sans', sans-serif;
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-secondary) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .empty-state .empty-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      text-align: center;
      max-width: 280px;
    }

    .empty-state svg {
      width: 48px;
      height: 48px;
      opacity: 0.5;
    }

    .empty-state p {
      font-size: 14px;
      text-align: center;
    }

    /* Date separator timestamp */
    .timestamp {
      font-size: 11px;
      color: var(--text-muted);
      text-align: center;
      padding: 8px 0;
    }

    /* Message footer (copy + timestamp) */
    .message-footer {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 6px;
    }

    .message-copy-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      opacity: 0;
      transition: all 0.15s ease;
      padding: 0;
    }

    .message:hover .message-copy-btn {
      opacity: 0.6;
    }

    .message-copy-btn:hover {
      opacity: 1 !important;
      color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
    }

    .message-copy-btn.copied {
      opacity: 1 !important;
      color: var(--success);
    }

    .message-copy-btn svg {
      width: 12px;
      height: 12px;
    }

    .message.user .message-copy-btn {
      color: rgba(255, 255, 255, 0.5);
    }

    .message.user .message-copy-btn:hover {
      color: white;
      background: rgba(255, 255, 255, 0.15);
    }

    .message.user .message-copy-btn.copied {
      color: white;
    }

    .message-timestamp {
      font-size: 10px;
      color: var(--text-muted);
      opacity: 0.7;
    }

    .message.user .message-timestamp {
      color: rgba(255, 255, 255, 0.6);
    }

    /* File Input (hidden) */
    #file-input {
      display: none;
    }

    /* Attachments */
    .attachments-container {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-top: 1px solid var(--border);
      max-height: 120px;
      overflow-y: auto;
    }

    .attachment-preview {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      font-size: 12px;
      color: var(--text-secondary);
      max-width: 200px;
    }

    .attachment-preview img {
      width: 32px;
      height: 32px;
      object-fit: cover;
      border-radius: 4px;
    }

    .attachment-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      flex-shrink: 0;
    }

    .attachment-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .attachment-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-primary);
    }

    .attachment-size {
      font-size: 11px;
      color: var(--text-muted);
    }

    .attachment-remove {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-muted);
      font-size: 14px;
      line-height: 1;
      padding: 0;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .attachment-remove:hover {
      background: var(--error);
      color: white;
    }

    /* Drag and Drop Overlay */
    .drag-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(168, 85, 247, 0.1);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      pointer-events: none;
    }

    .drag-overlay.active {
      display: flex;
    }

    .drag-overlay-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 48px 64px;
      background: var(--bg-secondary);
      border: 2px dashed var(--accent);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(168, 85, 247, 0.2);
    }

    .drag-overlay-icon {
      width: 64px;
      height: 64px;
      color: var(--accent);
      animation: bounce 0.6s ease infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    .drag-overlay-text {
      font-size: 18px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .drag-overlay-hint {
      font-size: 13px;
      color: var(--text-muted);
    }

    /* Attachment in messages */
    .message-attachments {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }

    .message-attachment {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      font-size: 12px;
    }

    .message-attachment img {
      max-width: 200px;
      max-height: 150px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <img src="../assets/tray-icon@2x.png" alt="" class="header-logo">
      <h1>Pocket Agent<span id="version-badge" class="version-badge"></span><span id="model-badge" class="model-badge"></span><span id="update-badge" class="update-badge" onclick="openSettings('updates')">Update</span></h1>
    </div>
    <div class="header-right">
      <div class="stats" id="stats"></div>
      <div class="hamburger-menu">
        <button class="hamburger-btn" onclick="playNormalClick(); toggleMenu()" id="hamburger-btn">
          <span></span>
          <span></span>
          <span></span>
        </button>
        <div class="menu-dropdown" id="menu-dropdown">
          <button class="menu-item" onclick="playNormalClick(); clearChat(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
              <path d="M3 3v5h5"/>
            </svg>
            Fresh Start
          </button>
          <button class="menu-item" onclick="playNormalClick(); showFacts(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 2a10 10 0 1 0 10 10H12V2z"/>
              <path d="M12 2a10 10 0 0 1 10 10"/>
              <circle cx="12" cy="12" r="6"/>
              <circle cx="12" cy="12" r="2"/>
            </svg>
            My Brain
          </button>
          <button class="menu-item" onclick="playNormalClick(); showSoul(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
            </svg>
            My Approach
          </button>
          <button class="menu-item" onclick="playNormalClick(); openFactsGraph(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="6" cy="6" r="3"/>
              <circle cx="18" cy="6" r="3"/>
              <circle cx="6" cy="18" r="3"/>
              <circle cx="18" cy="18" r="3"/>
              <line x1="8.5" y1="7.5" x2="15.5" y2="16.5"/>
              <line x1="15.5" y1="7.5" x2="8.5" y2="16.5"/>
            </svg>
            Mind Map
          </button>
          <button class="menu-item" onclick="playNormalClick(); openCustomize(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 20h9"/>
              <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/>
            </svg>
            Personalize
          </button>
          <button class="menu-item" onclick="playNormalClick(); openRoutines(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"/>
              <polyline points="12 6 12 12 16 14"/>
            </svg>
            Routines
          </button>
          <div class="menu-divider"></div>
          <button class="menu-item" onclick="playNormalClick(); openDocs(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
              <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
            </svg>
            Docs
          </button>
          <div class="menu-divider"></div>
          <button class="menu-item" onclick="playNormalClick(); openSettings(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="3"/>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
            </svg>
            Settings
          </button>
          <div class="menu-divider"></div>
          <button class="menu-item" onclick="playNormalClick(); openAbout(); closeMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"/>
              <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
              <line x1="12" y1="17" x2="12.01" y2="17"/>
            </svg>
            Who made me?
          </button>
        </div>
      </div>
    </div>
  </header>

  <!-- About Modal -->
  <div class="modal-overlay" id="about-modal" onclick="if(event.target === this) closeAbout();">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-icon"></div>
        <div class="modal-title">
          <h2>who made me?</h2>
          <p>the human behind franky</p>
        </div>
        <button class="modal-close" onclick="playNormalClick(); closeAbout();">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <div class="about-content">
          <p>hey, i'm <strong>Ken Kai</strong> - the guy who built me. he's been obsessed with AI and AI development for over 10 years now</p>
          <p>he runs a youtube channel where he shares everything he learns, and teaches on skool too</p>
          <p>if you want to learn more about AI dev, agents, and building cool stuff like me - check him out:</p>
        </div>
        <div class="about-links">
          <a class="about-link" onclick="playNormalClick(); window.pocketAgent.openExternal('https://www.youtube.com/@kenkaidoesai')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
              <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
            </svg>
            <span>@kenkaidoesai</span>
            <small>YouTube</small>
          </a>
          <a class="about-link" onclick="playNormalClick(); window.pocketAgent.openExternal('https://www.skool.com/kenkai')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M22 10v6M2 10l10-5 10 5-10 5z"/>
              <path d="M6 12v5c3 3 9 3 12 0v-5"/>
            </svg>
            <span>skool.com/kenkai</span>
            <small>Learn AI Dev</small>
          </a>
        </div>
      </div>
    </div>
  </div>

  <div class="tabs-container" id="tabs-container">
    <!-- Tabs will be populated by JavaScript -->
    <button class="new-tab-btn" onclick="playNormalClick(); createNewSession()" title="New chat">+</button>
  </div>

  <div id="messages"></div>

  <!-- Scroll Buttons -->
  <button id="scroll-top-btn" class="scroll-btn" onclick="playNormalClick(); scrollToTop()" title="Scroll to top">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>
  <button id="scroll-bottom-btn" class="scroll-btn" onclick="playNormalClick(); scrollToBottom()" title="Scroll to bottom">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  </button>

  <!-- Search Area -->
  <div id="search-area">
    <!-- Toggle Button (shown by default) -->
    <button class="search-toggle" id="search-toggle-btn" onclick="playNormalClick(); toggleSearch()">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
      <span>search</span>
    </button>
    <!-- Search Input (hidden by default) -->
    <div id="search-expanded">
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon">
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
      <input type="text" id="search-input" placeholder="Search in chat..." oninput="handleSearchInput(event)" onkeydown="handleSearchKeydown(event)">
      <span id="search-results-count" class="search-results-count"></span>
      <div class="search-nav">
        <button class="search-nav-btn" id="search-prev-btn" onclick="playNormalClick(); navigateSearch(-1)" title="Previous" disabled>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="18 15 12 9 6 15"></polyline>
          </svg>
        </button>
        <button class="search-nav-btn" id="search-next-btn" onclick="playNormalClick(); navigateSearch(1)" title="Next" disabled>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </button>
      </div>
      <button class="search-close-btn" onclick="playNormalClick(); closeSearch()" title="Close">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
  </div>

  <div id="input-area">
    <div class="input-container">
      <button class="attach-btn" onclick="playNormalClick(); triggerAttach()" title="Drop a file">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48"/>
        </svg>
      </button>
      <div class="textarea-wrapper">
        <div id="ghost-suggestion"></div>
        <textarea
          id="message-input"
          placeholder="what's on your mind? "
          rows="1"
          onkeydown="handleKeydown(event)"
          oninput="handleInput(event)"
        ></textarea>
      </div>
    </div>
    <button id="send-btn" onclick="handleSendClick()" title="Pounce! ">
      <svg class="send-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <!-- Paw pad (main) -->
        <ellipse cx="12" cy="14" rx="5" ry="4.5"/>
        <!-- Toe beans -->
        <ellipse cx="7" cy="8" rx="2" ry="2.5"/>
        <ellipse cx="17" cy="8" rx="2" ry="2.5"/>
        <ellipse cx="10" cy="5.5" rx="1.8" ry="2.2"/>
        <ellipse cx="14" cy="5.5" rx="1.8" ry="2.2"/>
      </svg>
      <svg class="stop-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <rect x="6" y="6" width="12" height="12" rx="2"/>
      </svg>
    </button>
  </div>

  <input type="file" id="file-input" onchange="handleFileSelect(event)" multiple
    accept=".txt,.md,.json,.csv,.xml,.html,.htm,.css,.js,.ts,.jsx,.tsx,.py,.rb,.go,.rs,.java,.c,.cpp,.h,.hpp,.sh,.yaml,.yml,.toml,.ini,.cfg,.conf,.log,.sql,.graphql,.pdf,.png,.jpg,.jpeg,.gif,.webp,.svg,.bmp,.ico">

  <!-- Click Sounds -->
  <audio id="click-sound" preload="auto" src="../assets/click.mp3"></audio>
  <audio id="normal-click-sound" preload="auto" src="../assets/normal-click.mp3"></audio>

  <!-- Drag and Drop Overlay -->
  <div id="drag-overlay" class="drag-overlay">
    <div class="drag-overlay-content">
      <svg class="drag-overlay-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="17 8 12 3 7 8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
      </svg>
      <div class="drag-overlay-text">Drop files here</div>
      <div class="drag-overlay-hint">Images, PDFs, code, and text files supported</div>
    </div>
  </div>

  <script>
    const messagesDiv = document.getElementById('messages');
    const input = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const statsDiv = document.getElementById('stats');
    const fileInput = document.getElementById('file-input');

    let isLoadingBySession = new Map(); // Track loading state per session
    let pendingAttachmentsBySession = new Map(); // Track attachments per session
    let statusCleanupBySession = new Map(); // Track status listeners per session
    let statusElBySession = new Map(); // Track status elements per session
    let suggestionBySession = new Map(); // Track ghost suggestions per session
    let inputTextBySession = new Map(); // Track input text per session
    let searchTextBySession = new Map(); // Track search input text per session
    let searchOpenBySession = new Map(); // Track search open state per session
    let queuedMessageIdsBySession = new Map(); // Track queued message IDs per session
    let pendingUserMessagesBySession = new Map(); // Track pending user message content per session
    const ghostSuggestion = document.getElementById('ghost-suggestion');
    let queuedMessageElements = new Map(); // Track queued message DOM elements by a unique ID

    // Helper to get current session's pending attachments
    function getPendingAttachments() {
      return pendingAttachmentsBySession.get(currentSessionId) || [];
    }
    function setPendingAttachments(attachments) {
      pendingAttachmentsBySession.set(currentSessionId, attachments);
    }
    // Helper to get current session's suggestion
    function getCurrentSuggestion() {
      return suggestionBySession.get(currentSessionId) || null;
    }
    function setCurrentSuggestion(suggestion) {
      suggestionBySession.set(currentSessionId, suggestion);
    }

    // Notification sound
    let notificationSound = null;
    let soundEnabled = true; // Will be loaded from settings

    // Initialize notification sound
    async function initNotificationSound() {
      try {
        soundEnabled = (await window.pocketAgent.getSetting('notifications.soundEnabled')) !== 'false';
        notificationSound = new Audio('../assets/pop.mp3');
        notificationSound.volume = 0.5;
      } catch (e) {
        console.warn('Failed to initialize notification sound:', e);
      }
    }

    // Play notification sound when response completes
    function playNotificationSound() {
      if (soundEnabled && notificationSound) {
        notificationSound.currentTime = 0;
        notificationSound.play().catch(() => {});
      }
    }

    // Click sounds
    const clickSound = document.getElementById('click-sound');
    const normalClickSound = document.getElementById('normal-click-sound');

    function playSendClick() {
      if (soundEnabled && clickSound) {
        clickSound.currentTime = 0;
        clickSound.play().catch(() => {});
      }
    }

    function playNormalClick() {
      if (soundEnabled && normalClickSound) {
        normalClickSound.currentTime = 0;
        normalClickSound.play().catch(() => {});
      }
    }

    // Session state
    const MAX_TABS = 5;
    let sessions = [];
    let currentSessionId = 'default';
    const tabsContainer = document.getElementById('tabs-container');

    // Allowed file types
    const ALLOWED_EXTENSIONS = new Set([
      // Text/Code
      'txt', 'md', 'json', 'csv', 'xml', 'html', 'htm', 'css', 'js', 'ts', 'jsx', 'tsx',
      'py', 'rb', 'go', 'rs', 'java', 'c', 'cpp', 'h', 'hpp', 'sh', 'yaml', 'yml',
      'toml', 'ini', 'cfg', 'conf', 'log', 'sql', 'graphql',
      // Images
      'png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp', 'ico',
      // Documents
      'pdf'
    ]);

    const IMAGE_EXTENSIONS = new Set(['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp', 'ico']);
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

    // Initialize
    window.addEventListener('DOMContentLoaded', async () => {
      // Load app version
      try {
        const version = await window.pocketAgent.getAppVersion();
        document.getElementById('version-badge').textContent = `v${version}`;
      } catch (err) {
        console.error('Failed to load app version:', err);
      }

      // Load current model
      await updateModelBadge();

      // Refresh model badge when window gains focus (in case user changed it in settings)
      window.addEventListener('focus', updateModelBadge);

      // Check for updates (delayed to not slow down startup)
      setTimeout(checkForUpdates, 3000);

      // Load sessions first, then load history for active session
      await loadSessions();
      await loadHistory();
      updateStats();
      input.focus();

      // Initialize notification sound
      initNotificationSound();

      // Listen for scheduler messages
      window.pocketAgent.onSchedulerMessage((data) => {
        console.log('[Chat] Received scheduler message:', data.jobName, 'sessionId:', data.sessionId, 'currentSession:', currentSessionId);
        handleSchedulerMessage(data);
      });

      // Listen for Telegram messages (cross-channel sync)
      console.log('[Chat] Setting up Telegram message listener');
      window.pocketAgent.onTelegramMessage((data) => {
        console.log('[Chat] Received Telegram message:', data);
        handleTelegramMessage(data);
      });
      console.log('[Chat] Telegram message listener set up');

      // Listen for session changes (e.g., Telegram link/unlink)
      window.pocketAgent.onSessionsChanged(() => {
        console.log('[Chat] Sessions changed, reloading...');
        loadSessions();
      });
    });

    // ============ SESSION MANAGEMENT ============

    async function loadSessions() {
      try {
        sessions = await window.pocketAgent.getSessions();
        // Restore last selected session from localStorage, or default to first session
        // Must be set BEFORE renderTabs() so the correct tab is highlighted
        if (sessions.length > 0) {
          const savedSessionId = localStorage.getItem('currentSessionId');
          const sessionExists = savedSessionId && sessions.some(s => s.id === savedSessionId);
          currentSessionId = sessionExists ? savedSessionId : sessions[0].id;
          // Save in case we defaulted to first session
          localStorage.setItem('currentSessionId', currentSessionId);
        }
        renderTabs();
      } catch (err) {
        console.error('Failed to load sessions:', err);
      }
    }

    let draggedTab = null;
    let draggedSessionId = null;

    function renderTabs() {
      // Remove existing tabs (keep the new tab button)
      const existingTabs = tabsContainer.querySelectorAll('.tab');
      existingTabs.forEach(tab => tab.remove());

      // Add tabs before the new tab button
      const newTabBtn = tabsContainer.querySelector('.new-tab-btn');

      sessions.forEach((session, index) => {
        const tab = document.createElement('div');
        const isActive = session.id === currentSessionId;
        const isLoading = isLoadingBySession.get(session.id);
        tab.className = 'tab' + (isActive ? ' active' : '') + (isLoading ? ' loading' : '');
        tab.dataset.sessionId = session.id;
        tab.dataset.index = index;
        tab.draggable = true;

        tab.onclick = (e) => {
          if (!e.target.closest('.tab-close') && !e.target.closest('.tab-name-input')) {
            playNormalClick();
            switchSession(session.id);
          }
        };
        tab.ondblclick = () => startRenameSession(session.id);

        // Drag events
        tab.ondragstart = (e) => {
          draggedTab = tab;
          draggedSessionId = session.id;
          setTimeout(() => tab.classList.add('dragging'), 0);
          e.dataTransfer.effectAllowed = 'move';
        };

        tab.ondragend = () => {
          if (draggedTab) {
            draggedTab.classList.remove('dragging');
          }
          draggedTab = null;
          draggedSessionId = null;
        };

        tab.ondragover = (e) => {
          e.preventDefault();
          if (!draggedTab || draggedSessionId === session.id) return;

          // Get the tab being hovered over
          const targetTab = tab;
          const rect = targetTab.getBoundingClientRect();
          const midpoint = rect.left + rect.width / 2;

          // Determine if we should insert before or after
          if (e.clientX < midpoint) {
            // Insert before this tab
            if (targetTab.previousElementSibling !== draggedTab) {
              tabsContainer.insertBefore(draggedTab, targetTab);
              updateSessionsOrder();
            }
          } else {
            // Insert after this tab
            if (targetTab.nextElementSibling !== draggedTab) {
              tabsContainer.insertBefore(draggedTab, targetTab.nextElementSibling);
              updateSessionsOrder();
            }
          }
        };

        const nameSpan = document.createElement('span');
        nameSpan.className = 'tab-name';
        nameSpan.textContent = session.name;
        tab.appendChild(nameSpan);

        // Show Telegram icon if session is linked to a Telegram group
        if (session.telegram_linked) {
          const telegramIcon = document.createElement('span');
          telegramIcon.className = 'tab-telegram-icon';
          telegramIcon.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>`;
          telegramIcon.title = session.telegram_group_name || 'Linked to Telegram';
          tab.appendChild(telegramIcon);
        }

        // Don't show close button for default session if it's the only one
        if (session.id !== 'default' || sessions.length > 1) {
          const closeBtn = document.createElement('button');
          closeBtn.className = 'tab-close';
          closeBtn.innerHTML = '';
          closeBtn.onclick = (e) => {
            e.stopPropagation();
            playNormalClick();
            confirmDeleteSession(session.id, session.name);
          };
          tab.appendChild(closeBtn);
        }

        tabsContainer.insertBefore(tab, newTabBtn);
      });

      // Hide new tab button when at max capacity
      newTabBtn.style.display = sessions.length >= MAX_TABS ? 'none' : '';
    }

    function updateSessionsOrder() {
      // Update sessions array to match current DOM order
      const tabs = tabsContainer.querySelectorAll('.tab');
      const newOrder = [];
      tabs.forEach(tab => {
        const sessionId = tab.dataset.sessionId;
        const session = sessions.find(s => s.id === sessionId);
        if (session) newOrder.push(session);
      });
      sessions = newOrder;
    }

    function confirmDeleteSession(sessionId, sessionName) {
      if (sessions.length <= 1) return;

      if (confirm(`Delete "${sessionName}"? This will remove all messages in this chat.`)) {
        deleteSession(sessionId);
      }
    }

    async function switchSession(sessionId) {
      if (sessionId === currentSessionId) return;

      // Save current session state before switching
      inputTextBySession.set(currentSessionId, input.value);

      // Save search state for current session
      const searchArea = document.getElementById('search-area');
      const searchInput = document.getElementById('search-input');
      searchTextBySession.set(currentSessionId, searchInput.value);
      searchOpenBySession.set(currentSessionId, searchArea.classList.contains('searching'));

      // Clear search UI (will restore for new session after load)
      searchArea.classList.remove('searching');
      searchInput.value = '';
      clearSearchHighlights();
      searchMatches = [];
      currentSearchIndex = 0;

      // Switch to new session
      currentSessionId = sessionId;
      localStorage.setItem('currentSessionId', currentSessionId);
      renderTabs();
      messagesDiv.innerHTML = '';
      await loadHistory();

      // Restore pending user messages that haven't been saved to history yet
      const pendingMsgs = pendingUserMessagesBySession.get(sessionId);
      const isLoading = isLoadingBySession.get(sessionId) || false;

      // Remove empty state if we have pending messages or an active query
      if ((pendingMsgs && pendingMsgs.size > 0) || isLoading) {
        const emptyState = messagesDiv.querySelector('.empty-state');
        if (emptyState) emptyState.remove();
      }

      if (pendingMsgs && pendingMsgs.size > 0) {
        pendingMsgs.forEach((msgData, msgId) => {
          const userMsgEl = addMessage('user', msgData.content, true, msgData.attachments);
          userMsgEl.dataset.messageId = msgId;
          // Check if this was a queued message
          const queuedIds = queuedMessageIdsBySession.get(sessionId) || new Set();
          if (queuedIds.has(msgId)) {
            userMsgEl.classList.add('queued');
            queuedMessageElements.set(msgId, userMsgEl);
          }
        });
      }

      updateStats();

      // Restore input text for this session
      input.value = inputTextBySession.get(sessionId) || '';
      // Auto-resize input to match content
      input.style.height = 'auto';
      input.style.height = Math.min(input.scrollHeight, 150) + 'px';

      // Restore ghost suggestion for this session
      const savedSuggestion = getCurrentSuggestion();
      if (savedSuggestion) {
        ghostSuggestion.innerHTML = escapeHtml(savedSuggestion) + '<span class="tab-hint">Tab to accept</span>';
        ghostSuggestion.style.display = 'block';
      } else {
        ghostSuggestion.innerHTML = '';
        ghostSuggestion.style.display = 'none';
      }

      // Restore search state for this session
      const savedSearchText = searchTextBySession.get(sessionId) || '';
      const wasSearchOpen = searchOpenBySession.get(sessionId) || false;
      if (wasSearchOpen || savedSearchText) {
        searchInput.value = savedSearchText;
        if (wasSearchOpen) {
          searchArea.classList.add('searching');
          // Re-run search to highlight matches in new session's messages
          if (savedSearchText) {
            performSearch(savedSearchText);
          }
        }
      }

      // Restore attachment previews for this session
      renderAttachmentPreviews();

      // Update button state based on whether THIS session is loading
      setButtonState(isLoading);

      // Restore status indicator if this session has an active query
      if (isLoading) {
        // Create a new status indicator for this session
        const existingStatusEl = statusElBySession.get(sessionId);
        if (!existingStatusEl || !messagesDiv.contains(existingStatusEl)) {
          const statusEl = addStatusIndicator('*stretches paws* thinking...');
          statusElBySession.set(sessionId, statusEl);
        }
      }

      input.focus();
    }

    async function createNewSession() {
      // Check tab limit
      if (sessions.length >= MAX_TABS) {
        return;
      }

      try {
        const result = await window.pocketAgent.createSession('New');
        if (!result.success || !result.session) {
          addMessage('system', result.error || 'Failed to create session');
          return;
        }
        sessions.push(result.session); // Add to end (right side)
        currentSessionId = result.session.id;
        renderTabs();
        messagesDiv.innerHTML = '';
        showEmptyState();
        updateStats();
        input.focus();
        // Start rename immediately
        setTimeout(() => startRenameSession(result.session.id), 100);
      } catch (err) {
        console.error('Failed to create session:', err);
      }
    }

    function startRenameSession(sessionId) {
      const tab = tabsContainer.querySelector(`[data-session-id="${sessionId}"]`);
      if (!tab) return;

      const nameSpan = tab.querySelector('.tab-name');
      const currentName = nameSpan.textContent;

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'tab-name-input';
      input.value = currentName;
      input.maxLength = 10;

      // Sanitize input: single word only (no spaces), max 10 chars
      input.oninput = () => {
        // Remove spaces and limit to 10 chars
        input.value = input.value.replace(/\s/g, '').slice(0, 10);
      };

      input.onblur = () => finishRename(sessionId, input.value);
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          input.blur();
        } else if (e.key === 'Escape') {
          input.value = currentName;
          input.blur();
        } else if (e.key === ' ') {
          // Prevent space key
          e.preventDefault();
        }
      };

      nameSpan.replaceWith(input);
      input.focus();
      input.select();
    }

    async function finishRename(sessionId, newName) {
      // Sanitize: remove spaces, limit to 10 chars, fallback to 'Untitled'
      const sanitizedName = newName.replace(/\s/g, '').slice(0, 10) || 'Untitled';

      try {
        const result = await window.pocketAgent.renameSession(sessionId, sanitizedName);
        if (!result.success) {
          // Show error (likely duplicate name)
          addMessage('system', result.error || 'Failed to rename session');
          renderTabs(); // Revert UI
          return;
        }
        // Update local state
        const session = sessions.find(s => s.id === sessionId);
        if (session) {
          session.name = sanitizedName;
        }
        renderTabs();
      } catch (err) {
        console.error('Failed to rename session:', err);
        renderTabs(); // Revert UI
      }
    }

    async function deleteSession(sessionId) {
      if (sessions.length <= 1) {
        // Can't delete the last session
        return;
      }

      try {
        // Clean up status listener for this session
        const statusCleanup = statusCleanupBySession.get(sessionId);
        if (statusCleanup) {
          statusCleanup();
          statusCleanupBySession.delete(sessionId);
        }

        // Remove status indicator element
        const statusEl = statusElBySession.get(sessionId);
        if (statusEl) {
          statusEl.remove();
          statusElBySession.delete(sessionId);
        }

        // Clean up loading state
        isLoadingBySession.delete(sessionId);

        // Clean up queued message tracking for this session
        const queuedIds = queuedMessageIdsBySession.get(sessionId);
        if (queuedIds) {
          for (const msgId of queuedIds) {
            queuedMessageElements.delete(msgId);
          }
          queuedMessageIdsBySession.delete(sessionId);
        }

        // Clean up pending user messages
        pendingUserMessagesBySession.delete(sessionId);

        // Now delete the session (this also stops any running query)
        const result = await window.pocketAgent.deleteSession(sessionId);

        if (!result.success) {
          console.error('Failed to delete session from database');
          // Refresh sessions from DB to ensure UI is in sync
          sessions = await window.pocketAgent.getSessions();
          renderTabs();
          return;
        }

        sessions = sessions.filter(s => s.id !== sessionId);

        // If we deleted the current session, switch to another
        if (sessionId === currentSessionId) {
          currentSessionId = sessions[0]?.id || 'default';
          localStorage.setItem('currentSessionId', currentSessionId);
          messagesDiv.innerHTML = '';
          await loadHistory();
        }

        renderTabs();
        updateStats();
      } catch (err) {
        console.error('Failed to delete session:', err);
        // Refresh sessions from DB to ensure UI is in sync
        sessions = await window.pocketAgent.getSessions();
        renderTabs();
      }
    }

    function handleSchedulerMessage(data) {
      console.log(`[Chat] handleSchedulerMessage called - data.sessionId: ${data.sessionId}, currentSessionId: ${currentSessionId}`);
      // Only show message if it's for the current session
      if (data.sessionId && data.sessionId !== currentSessionId) {
        console.log(`[Chat] SKIPPING - session mismatch`);
        return;
      }
      console.log(`[Chat] DISPLAYING - session matches or no sessionId`);

      // Clear empty state if present
      const emptyState = messagesDiv.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Add the user prompt with scheduled badge
      if (data.prompt) {
        const promptEl = addMessage('user', data.prompt);
        if (data.jobName) {
          promptEl.classList.add('scheduled');
          promptEl.dataset.badge = data.jobName;
        }
      }

      // Add the agent's response with scheduled badge
      const msgEl = addMessage('assistant', data.response);
      if (data.jobName) {
        msgEl.classList.add('scheduled');
        msgEl.dataset.badge = data.jobName;
      }

      // Update stats and scroll
      updateStats();
      scrollToBottom();

      // Focus window
      window.focus();
    }

    function handleTelegramMessage(data) {
      // Only show message if it's for the current session
      // (messages are already saved to SQLite for the correct session)
      if (data.sessionId && data.sessionId !== currentSessionId) {
        console.log(`[Chat] Telegram message for session ${data.sessionId}, current is ${currentSessionId} - skipping display`);
        return;
      }

      // Clear empty state if present
      const emptyState = messagesDiv.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Add Telegram indicator + user message
      addTelegramMessage('user', data.userMessage, data.hasAttachment, data.attachmentType);

      // Add the agent's response
      addMessage('assistant', data.response);

      // Update stats and scroll
      updateStats();
      scrollToBottom();
    }

    // Helper to get appropriate label for attachment type
    function getAttachmentLabel(hasAttachment, attachmentType) {
      if (!hasAttachment) return '';
      switch (attachmentType) {
        case 'photo': return ' ';
        case 'voice': return ' Voice note';
        case 'audio': return ' ';
        default: return ' ';
      }
    }

    function addTelegramMessage(role, content, hasAttachment = false, attachmentType = null) {
      const wrapper = document.createElement('div');
      wrapper.className = `message ${role} from-telegram`;

      // Get attachment icon based on type
      const attachmentLabel = getAttachmentLabel(hasAttachment, attachmentType);

      // Telegram badge with icon
      const badge = document.createElement('div');
      badge.className = 'telegram-badge';
      badge.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>${attachmentLabel}`;
      wrapper.appendChild(badge);

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      contentDiv.innerHTML = formatContent(content);
      // Intercept link clicks to open in external browser
      contentDiv.addEventListener('click', (e) => {
        const link = e.target.closest('a[href]');
        if (link) {
          e.preventDefault();
          const href = link.getAttribute('href');
          if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
            window.pocketAgent.openExternal(href);
          }
        }
      });
      wrapper.appendChild(contentDiv);

      // Add timestamp
      const timestampDiv = document.createElement('div');
      timestampDiv.className = 'message-timestamp';
      timestampDiv.textContent = formatTimestamp(new Date());
      wrapper.appendChild(timestampDiv);

      messagesDiv.appendChild(wrapper);
      return wrapper;
    }

    async function loadHistory() {
      try {
        const history = await window.pocketAgent.getHistory(100, currentSessionId);
        messagesDiv.innerHTML = '';

        if (history.length === 0) {
          showEmptyState();
        } else {
          let lastDate = null;
          for (let i = 0; i < history.length; i++) {
            const msg = history[i];
            // Add date separator if needed
            const msgDate = parseSqliteTimestamp(msg.timestamp).toLocaleDateString();
            if (msgDate !== lastDate) {
              addTimestamp(msgDate);
              lastDate = msgDate;
            }

            const msgEl = addMessage(msg.role, msg.content, false, [], msg.timestamp);
            // Add scheduled badge if message came from scheduler
            if (msg.metadata?.source === 'scheduler' && msg.metadata?.jobName) {
              msgEl.classList.add('scheduled');
              msgEl.dataset.badge = msg.metadata.jobName;
            }
            // Add Telegram badge if message came from Telegram
            if (msg.metadata?.source === 'telegram') {
              msgEl.classList.add('from-telegram');
              const badge = document.createElement('div');
              badge.className = 'telegram-badge';
              const attachmentLabel = getAttachmentLabel(msg.metadata.hasAttachment, msg.metadata.attachmentType);
              badge.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>${attachmentLabel}`;
              msgEl.insertBefore(badge, msgEl.firstChild);
            }
          }
        }

        scrollToBottom(true); // Instant scroll on initial load
      } catch (err) {
        console.error('Failed to load history:', err);
        showEmptyState();
      }
    }

    async function updateStats() {
      try {
        const stats = await window.pocketAgent.getStats(currentSessionId);
        if (stats) {
          const tokens = stats.estimatedTokens >= 1000
            ? `${(stats.estimatedTokens / 1000).toFixed(1)}k`
            : stats.estimatedTokens;
          statsDiv.textContent = `${stats.messageCount} msgs  ${stats.factCount} facts  ${tokens} tokens`;
        }
      } catch (err) {
        console.error('Failed to get stats:', err);
      }
    }

    async function updateModelBadge() {
      try {
        const modelId = await window.pocketAgent.getSetting('agent.model');
        const modelNames = {
          'claude-opus-4-5-20251101': 'OPUS 4.5',
          'claude-sonnet-4-5-20250929': 'SONNET 4.5',
          'claude-haiku-4-5-20251001': 'HAIKU 4.5',
          'kimi-k2.5': 'KIMI K2.5',
          'glm-4.7': 'GLM-4.7',
        };
        const displayName = modelNames[modelId] || modelId.toUpperCase();
        document.getElementById('model-badge').textContent = displayName;
      } catch (err) {
        console.error('Failed to load model:', err);
      }
    }

    function handleSendClick() {
      playSendClick();
      if (isLoadingBySession.get(currentSessionId)) {
        stopQuery();
      } else {
        sendMessage();
      }
    }

    function setButtonState(loading) {
      const sendIcon = sendBtn.querySelector('.send-icon');
      const stopIcon = sendBtn.querySelector('.stop-icon');

      if (loading) {
        sendBtn.classList.add('stop-btn');
        sendBtn.title = 'Stop it!';
        sendIcon.style.display = 'none';
        stopIcon.style.display = 'block';
        sendBtn.disabled = false;
      } else {
        sendBtn.classList.remove('stop-btn');
        sendBtn.title = 'Send it!';
        sendIcon.style.display = 'block';
        stopIcon.style.display = 'none';
      }
    }

    async function stopQuery() {
      const sessionId = currentSessionId;
      try {
        await window.pocketAgent.stop(sessionId);

        // Clean up status listener for this session
        const statusCleanup = statusCleanupBySession.get(sessionId);
        if (statusCleanup) {
          statusCleanup();
          statusCleanupBySession.delete(sessionId);
        }

        // Remove status indicator for this session
        const statusEl = statusElBySession.get(sessionId);
        if (statusEl) {
          statusEl.remove();
          statusElBySession.delete(sessionId);
        }

        // Remove 'queued' class from any queued messages and clear tracking
        const queuedMsgs = messagesDiv.querySelectorAll('.message.queued');
        queuedMsgs.forEach(msg => msg.classList.remove('queued'));
        queuedMessageElements.clear();

        addMessage('system', 'query stopped', true, [], null, false);

        isLoadingBySession.set(sessionId, false);
        renderTabs(); // Update tab loading indicator
        setButtonState(false);
        scrollToBottom();
        input.focus();
      } catch (err) {
        console.error('Failed to stop query:', err);
      }
    }

    async function sendMessage() {
      const message = input.value.trim();
      const attachments = [...getPendingAttachments()];
      const sessionId = currentSessionId; // Capture session at start

      if (!message && attachments.length === 0) return;

      // Clear empty state if present
      const emptyState = messagesDiv.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Check if already processing - if so, message will be queued
      const isQueued = isLoadingBySession.get(sessionId);
      const messageId = `msg-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;

      // Always clear input immediately for responsive UX
      input.value = '';
      input.style.height = 'auto';
      clearSuggestion();
      clearAttachments();

      // Show user message - mark as queued if there's already a message processing
      const userMsgEl = addMessage('user', message, true, attachments);
      userMsgEl.dataset.messageId = messageId;

      // Track pending user message for session state restoration
      if (!pendingUserMessagesBySession.has(sessionId)) {
        pendingUserMessagesBySession.set(sessionId, new Map());
      }
      pendingUserMessagesBySession.get(sessionId).set(messageId, { content: message, attachments: attachments });

      if (isQueued) {
        userMsgEl.classList.add('queued');
        userMsgEl.dataset.messageId = messageId;
        queuedMessageElements.set(messageId, userMsgEl);
        // Track queued message ID for session state restoration
        if (!queuedMessageIdsBySession.has(sessionId)) {
          queuedMessageIdsBySession.set(sessionId, new Set());
        }
        queuedMessageIdsBySession.get(sessionId).add(messageId);
      }

      // If not already processing, show status indicator and set loading state
      if (!isQueued) {
        isLoadingBySession.set(sessionId, true);
        renderTabs();
        setButtonState(true);
        const statusEl = addStatusIndicator('*stretches paws* thinking...');
        statusElBySession.set(sessionId, statusEl);
      }

      scrollToBottom();

      // Build the full message with attachments
      const fullMessage = await buildMessageWithAttachments(message, attachments);

      // Set up status listener for this session (only if not already set up)
      if (!statusCleanupBySession.has(sessionId)) {
        const statusCleanup = window.pocketAgent.onStatus((status) => {
          // Only update status if we're still on the same session
          if (currentSessionId === sessionId) {
            updateStatusIndicator(status, sessionId);
          }
        });
        statusCleanupBySession.set(sessionId, statusCleanup);
      }

      try {
        // This will resolve when the message is actually processed (not when queued)
        const result = await window.pocketAgent.send(fullMessage, sessionId);

        // If this message was queued, remove the queued state
        if (queuedMessageElements.has(messageId)) {
          const msgEl = queuedMessageElements.get(messageId);
          if (msgEl) {
            msgEl.classList.remove('queued');
          }
          queuedMessageElements.delete(messageId);
          // Remove from session tracking
          const queuedIds = queuedMessageIdsBySession.get(sessionId);
          if (queuedIds) queuedIds.delete(messageId);
        }

        // Remove from pending user messages (message is now saved to history)
        const pendingMsgs = pendingUserMessagesBySession.get(sessionId);
        if (pendingMsgs) pendingMsgs.delete(messageId);

        // Only update UI if still on same session
        if (currentSessionId === sessionId) {
          // Check if there are more queued messages - if not, clean up
          const hasMoreQueued = queuedMessageElements.size > 0;

          if (!hasMoreQueued) {
            // Clean up status listener
            const cleanup = statusCleanupBySession.get(sessionId);
            if (cleanup) {
              cleanup();
              statusCleanupBySession.delete(sessionId);
            }

            // Remove status indicator
            const currentStatusEl = statusElBySession.get(sessionId);
            if (currentStatusEl) {
              currentStatusEl.remove();
              statusElBySession.delete(sessionId);
            }

            isLoadingBySession.set(sessionId, false);
            renderTabs();
            setButtonState(false);
          }

          if (result.success) {
            addMessage('assistant', result.response);

            // If there's a suggested prompt, show it as ghost text
            if (result.suggestedPrompt) {
              setSuggestion(result.suggestedPrompt);
            }
          } else {
            // Don't show stop/abort related errors - they're already handled
            const errorMsg = result.error || '';
            if (!errorMsg.includes('stopped') && !errorMsg.includes('aborted') && !errorMsg.includes('Aborted')) {
              addMessage('error', errorMsg);
            }
          }

          updateStats();
          scrollToBottom();
        }
      } catch (err) {
        // If this message was queued, remove the queued state
        if (queuedMessageElements.has(messageId)) {
          const msgEl = queuedMessageElements.get(messageId);
          if (msgEl) {
            msgEl.classList.remove('queued');
          }
          queuedMessageElements.delete(messageId);
          // Remove from session tracking
          const queuedIds = queuedMessageIdsBySession.get(sessionId);
          if (queuedIds) queuedIds.delete(messageId);
        }

        // Remove from pending user messages (message is now saved to history)
        const pendingMsgsErr = pendingUserMessagesBySession.get(sessionId);
        if (pendingMsgsErr) pendingMsgsErr.delete(messageId);

        // Check if there are more queued messages
        const hasMoreQueued = queuedMessageElements.size > 0;

        if (!hasMoreQueued) {
          // Clean up status listener
          const cleanup = statusCleanupBySession.get(sessionId);
          if (cleanup) {
            cleanup();
            statusCleanupBySession.delete(sessionId);
          }

          const currentStatusEl = statusElBySession.get(sessionId);
          if (currentStatusEl) {
            currentStatusEl.remove();
            statusElBySession.delete(sessionId);
          }

          isLoadingBySession.set(sessionId, false);
          renderTabs();
          setButtonState(false);
        }

        // Only show error if still on same session and not stopped/cleared/aborted
        if (currentSessionId === sessionId && !err.message?.includes('stopped') && !err.message?.includes('cleared') && !err.message?.includes('aborted') && !err.message?.includes('Aborted')) {
          addMessage('error', err.message || 'Something went wrong');
        }

        scrollToBottom();
      }

      input.focus();
    }

    async function buildMessageWithAttachments(message, attachments) {
      if (attachments.length === 0) return message;

      const parts = [];

      // Add text message if present
      if (message) {
        parts.push(message);
      }

      // Add attachments
      for (const att of attachments) {
        if (att.isImage && att.dataUrl) {
          // Save image to temp file and reference path
          try {
            const filePath = await window.pocketAgent.saveAttachment(att.name, att.dataUrl);
            parts.push(`\n\n[Attached image: ${att.name}]\nFile saved at: ${filePath}\nUse the Read tool to view this image.`);
          } catch (err) {
            parts.push(`\n\n[Image: ${att.name}] (failed to save: ${err.message})`);
          }
        } else if (att.ext === 'pdf' && att.dataUrl) {
          // Save PDF to temp file and reference path
          try {
            const filePath = await window.pocketAgent.saveAttachment(att.name, att.dataUrl);
            parts.push(`\n\n[Attached PDF: ${att.name}]\nFile saved at: ${filePath}\nUse the Read tool to view this PDF.`);
          } catch (err) {
            parts.push(`\n\n[PDF: ${att.name}] (failed to save: ${err.message})`);
          }
        } else if (att.content) {
          // For text files, include content directly (truncate if very large)
          const content = att.content.length > 50000
            ? att.content.slice(0, 50000) + '\n... (truncated)'
            : att.content;
          parts.push(`\n\n[File: ${att.name}]\n\`\`\`${att.ext}\n${content}\n\`\`\``);
        }
      }

      return parts.join('');
    }

    async function clearChat() {
      if (!confirm('Start fresh? Don\'t worry - I\'ll keep everything I know about you!')) return;

      try {
        await window.pocketAgent.clearConversation(currentSessionId);
        messagesDiv.innerHTML = '';
        showEmptyState();
        updateStats();
      } catch (err) {
        addMessage('error', err.message);
      }
    }

    async function showFacts() {
      try {
        await window.pocketAgent.openFacts();
      } catch (err) {
        console.error('Failed to open facts:', err);
      }
    }

    async function showSoul() {
      try {
        await window.pocketAgent.openSoul();
      } catch (err) {
        console.error('Failed to open soul:', err);
      }
    }

    function addMessage(role, content, animate = true, attachments = [], timestamp = null, showTimestamp = true) {
      const div = document.createElement('div');
      div.className = `message ${role}`;
      if (!animate) div.style.animation = 'none';

      // Add attachments display for user messages
      if (attachments && attachments.length > 0) {
        const attDiv = document.createElement('div');
        attDiv.className = 'message-attachments';

        for (const att of attachments) {
          const attItem = document.createElement('div');
          attItem.className = 'message-attachment';

          if (att.isImage && att.dataUrl) {
            const img = document.createElement('img');
            img.src = att.dataUrl;
            img.alt = att.name;
            attItem.appendChild(img);
          } else {
            attItem.innerHTML = `<span class="attachment-icon">${escapeHtml(att.ext)}</span> ${escapeHtml(att.name)}`;
          }

          attDiv.appendChild(attItem);
        }

        div.appendChild(attDiv);
      }

      // Add text content
      if (content) {
        const contentDiv = document.createElement('div');
        contentDiv.innerHTML = formatContent(content);
        // Append children directly to avoid nesting issues
        while (contentDiv.firstChild) {
          div.appendChild(contentDiv.firstChild);
        }
        // Intercept link clicks to open in external browser
        div.addEventListener('click', (e) => {
          const link = e.target.closest('a[href]');
          if (link) {
            e.preventDefault();
            const href = link.getAttribute('href');
            if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
              window.pocketAgent.openExternal(href);
            }
          }
        });
      }

      // Add footer with copy button and timestamp
      if (showTimestamp) {
        const ts = timestamp ? parseSqliteTimestamp(timestamp) : new Date();
        const footerDiv = document.createElement('div');
        footerDiv.className = 'message-footer';

        // Copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'message-copy-btn';
        copyBtn.title = 'Copy';
        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>`;
        copyBtn.onclick = (e) => {
          e.stopPropagation();
          copyMessageText(div, copyBtn);
        };
        footerDiv.appendChild(copyBtn);

        // Timestamp
        const timestampDiv = document.createElement('div');
        timestampDiv.className = 'message-timestamp';
        timestampDiv.textContent = formatTimestamp(ts);
        footerDiv.appendChild(timestampDiv);

        div.appendChild(footerDiv);
      }

      // Insert before status indicator if one exists (keeps indicator at bottom)
      const statusIndicator = messagesDiv.querySelector('.status-indicator');
      if (statusIndicator) {
        messagesDiv.insertBefore(div, statusIndicator);
      } else {
        messagesDiv.appendChild(div);
      }
      return div;
    }

    // Parse SQLite timestamp consistently (SQLite stores UTC with 'Z' suffix)
    function parseSqliteTimestamp(timestamp) {
      if (!timestamp) return new Date();

      // Check if timestamp has an explicit timezone indicator (Z, +HH:MM, -HH:MM, +HHMM, -HHMM)
      const hasTimezone = /Z$|[+-]\d{2}:?\d{2}$/.test(timestamp);

      if (hasTimezone) {
        // Already has timezone info, parse directly
        return new Date(timestamp);
      }

      // Legacy fallback: old timestamps without timezone (assumed UTC)
      const normalized = timestamp.replace(' ', 'T');
      return new Date(normalized + 'Z');
    }

    function formatTimestamp(date) {
      const now = new Date();
      const isToday = date.toDateString() === now.toDateString();

      const timeStr = date.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });

      if (isToday) {
        return `Today, ${timeStr}`;
      }

      const dateStr = date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric'
      });

      return `${dateStr}, ${timeStr}`;
    }

    function formatContent(text) {
      // Use marked for full markdown rendering
      if (typeof marked !== 'undefined') {
        marked.setOptions({
          breaks: true, // Convert \n to <br>
          gfm: true, // GitHub flavored markdown
        });
        let html = marked.parse(text);
        // Wrap tables in scrollable container
        html = html.replace(/<table>/g, '<div class="table-wrapper"><table>');
        html = html.replace(/<\/table>/g, '</table></div>');
        return html;
      }
      // Fallback if marked isn't loaded
      return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function addTimestamp(date) {
      const div = document.createElement('div');
      div.className = 'timestamp';
      div.textContent = date;
      messagesDiv.appendChild(div);
    }

    function addTyping() {
      const div = document.createElement('div');
      div.className = 'typing';
      div.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';
      messagesDiv.appendChild(div);
      return div;
    }

    function addStatusIndicator(initialMessage) {
      const div = document.createElement('div');
      div.className = 'status-indicator';
      div.innerHTML = `
        <div class="status-spinner"></div>
        <div class="status-content">
          <div class="status-action">${escapeHtml(initialMessage)}</div>
          <div class="status-detail"></div>
        </div>
      `;
      messagesDiv.appendChild(div);
      return div;
    }

    function updateStatusIndicator(status, sessionId) {
      // Use sessionId if provided, otherwise fall back to current session
      const targetSession = sessionId || currentSessionId;
      const statusEl = statusElBySession.get(targetSession);
      if (!statusEl) return;

      const actionEl = statusEl.querySelector('.status-action');
      const detailEl = statusEl.querySelector('.status-detail');

      console.log('[UI] Status received:', status.type, status);

      if (status.type === 'thinking') {
        // Don't overwrite blocked state
        if (!statusEl.classList.contains('tool-blocked')) {
          actionEl.textContent = status.message || '*stretches paws* thinking...';
          detailEl.textContent = '';
          detailEl.style.display = 'none';
          statusEl.classList.remove('subagent-active');
        }
      } else if (status.type === 'tool_start') {
        actionEl.textContent = status.toolName || 'pouncing on it...';
        if (status.toolInput) {
          detailEl.textContent = status.toolInput;
          detailEl.title = status.toolInput;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
        statusEl.classList.remove('subagent-active');
      } else if (status.type === 'tool_end') {
        // Don't overwrite blocked state - keep showing the block message
        if (!statusEl.classList.contains('tool-blocked')) {
          actionEl.textContent = status.message || 'caught it! processing...';
          detailEl.textContent = '';
          detailEl.style.display = 'none';
          statusEl.classList.remove('subagent-active');
        }
      } else if (status.type === 'tool_blocked') {
        // Safety hook blocked a dangerous command
        statusEl.classList.add('tool-blocked');
        actionEl.textContent = status.message || ' whoa! not allowed!';
        if (status.blockedReason) {
          detailEl.textContent = status.blockedReason;
          detailEl.title = status.blockedReason;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
        statusEl.classList.remove('subagent-active');
      } else if (status.type === 'subagent_start') {
        // Subagent spawned - show special status
        statusEl.classList.add('subagent-active');
        actionEl.textContent = status.message || 'summoning cat friends';
        if (status.toolInput) {
          const countBadge = status.agentCount > 1 ? ` (${status.agentCount} active)` : '';
          detailEl.textContent = status.toolInput + countBadge;
          detailEl.title = status.toolInput;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = status.agentCount > 1 ? `${status.agentCount} helpers active` : '';
          detailEl.style.display = status.agentCount > 1 ? 'block' : 'none';
        }
      } else if (status.type === 'subagent_update') {
        // Multiple subagents, one finished
        actionEl.textContent = status.message || `${status.agentCount} kitties on the job`;
        detailEl.textContent = '';
        detailEl.style.display = 'none';
      } else if (status.type === 'subagent_end') {
        // All subagents done
        statusEl.classList.remove('subagent-active');
        actionEl.textContent = status.message || 'cat squad finished! ';
        detailEl.textContent = '';
        detailEl.style.display = 'none';
      } else if (status.type === 'responding') {
        actionEl.textContent = 'grooming my response... ';
        detailEl.textContent = '';
        detailEl.style.display = 'none';
        statusEl.classList.remove('subagent-active');
      } else if (status.type === 'queued') {
        // Message was queued - show queue position
        actionEl.textContent = status.message || 'in the litter queue ';
        if (status.queuePosition) {
          detailEl.textContent = `Position #${status.queuePosition} in queue`;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
        statusEl.classList.remove('subagent-active');
      } else if (status.type === 'queue_processing') {
        // Now processing a queued message
        actionEl.textContent = status.message || 'digging it up now...';
        if (status.queuedMessage) {
          detailEl.textContent = status.queuedMessage;
          detailEl.title = status.queuedMessage;
          detailEl.style.display = 'block';
        } else {
          detailEl.textContent = '';
          detailEl.style.display = 'none';
        }
        statusEl.classList.remove('subagent-active');

        // Remove 'queued' class from the oldest queued message since it's now processing
        const queuedMsgs = messagesDiv.querySelectorAll('.message.queued');
        if (queuedMsgs.length > 0) {
          queuedMsgs[0].classList.remove('queued');
        }
      } else if (status.type === 'done') {
        // Response complete - play notification sound
        playNotificationSound();
      }

      scrollToBottom();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function copyMessageText(messageEl, copyBtn) {
      // Get text content, excluding footer (timestamp, copy button)
      const clone = messageEl.cloneNode(true);
      const footer = clone.querySelector('.message-footer');
      if (footer) footer.remove();
      const attachments = clone.querySelector('.message-attachments');
      if (attachments) attachments.remove();

      const text = clone.textContent.trim();

      navigator.clipboard.writeText(text).then(() => {
        // Show copied state
        copyBtn.classList.add('copied');
        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>`;

        setTimeout(() => {
          copyBtn.classList.remove('copied');
          copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>`;
        }, 1500);
      }).catch(err => {
        console.error('Failed to copy:', err);
      });
    }

    // Search functionality
    let searchMatches = [];
    let currentSearchIndex = -1;
    let searchDebounceTimer = null;

    function toggleSearch() {
      const searchArea = document.getElementById('search-area');
      const searchInput = document.getElementById('search-input');

      if (searchArea.classList.contains('searching')) {
        closeSearch();
      } else {
        searchArea.classList.add('searching');
        searchInput.focus();
      }
    }

    function closeSearch() {
      const searchArea = document.getElementById('search-area');
      const searchInput = document.getElementById('search-input');

      searchArea.classList.remove('searching');
      searchInput.value = '';
      clearSearchHighlights();
      updateSearchResultsCount(0, 0);
      searchMatches = [];
      currentSearchIndex = -1;
    }

    function handleSearchInput(event) {
      // Debounce search
      clearTimeout(searchDebounceTimer);
      searchDebounceTimer = setTimeout(() => {
        performSearch(event.target.value);
      }, 150);
    }

    function handleSearchKeydown(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        if (event.shiftKey) {
          navigateSearch(-1);
        } else {
          navigateSearch(1);
        }
      } else if (event.key === 'Escape') {
        event.preventDefault();
        closeSearch();
      }
    }

    function performSearch(query) {
      clearSearchHighlights();
      searchMatches = [];
      currentSearchIndex = -1;

      if (!query || query.trim().length === 0) {
        updateSearchResultsCount(0, 0);
        updateNavButtons();
        return;
      }

      const searchTerm = query.trim().toLowerCase();
      const messages = messagesDiv.querySelectorAll('.message');

      messages.forEach(msg => {
        // Search in text nodes, excluding timestamps and other meta elements
        const walker = document.createTreeWalker(
          msg,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode: function(node) {
              // Skip timestamps and attachment meta
              if (node.parentElement.classList.contains('message-timestamp') ||
                  node.parentElement.classList.contains('message-attachment') ||
                  node.parentElement.classList.contains('attachment-icon')) {
                return NodeFilter.FILTER_REJECT;
              }
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );

        let node;
        while (node = walker.nextNode()) {
          const text = node.textContent;
          const lowerText = text.toLowerCase();
          let startIndex = 0;
          let index;

          while ((index = lowerText.indexOf(searchTerm, startIndex)) !== -1) {
            searchMatches.push({
              node: node,
              startOffset: index,
              endOffset: index + searchTerm.length,
              message: msg
            });
            startIndex = index + 1;
          }
        }
      });

      // Apply highlights
      highlightMatches();
      updateSearchResultsCount(searchMatches.length > 0 ? 1 : 0, searchMatches.length);
      updateNavButtons();

      // Navigate to first match
      if (searchMatches.length > 0) {
        currentSearchIndex = 0;
        scrollToCurrentMatch();
      }
    }

    function highlightMatches() {
      // Process matches in reverse order to avoid offset issues
      const matchesByNode = new Map();

      searchMatches.forEach((match, index) => {
        if (!matchesByNode.has(match.node)) {
          matchesByNode.set(match.node, []);
        }
        matchesByNode.get(match.node).push({ ...match, index });
      });

      matchesByNode.forEach((nodeMatches, node) => {
        // Sort in reverse order for safe replacement
        nodeMatches.sort((a, b) => b.startOffset - a.startOffset);

        const text = node.textContent;
        const parent = node.parentNode;
        const fragment = document.createDocumentFragment();

        let currentText = text;
        let parts = [];

        // Build parts array
        for (const match of nodeMatches) {
          const before = currentText.slice(match.endOffset);
          const matchText = currentText.slice(match.startOffset, match.endOffset);
          const remaining = currentText.slice(0, match.startOffset);

          parts.unshift({ type: 'text', content: before });
          parts.unshift({ type: 'match', content: matchText, index: match.index });

          currentText = remaining;
        }
        parts.unshift({ type: 'text', content: currentText });

        // Create nodes from parts
        parts.forEach(part => {
          if (part.type === 'text') {
            if (part.content) {
              fragment.appendChild(document.createTextNode(part.content));
            }
          } else {
            const mark = document.createElement('mark');
            mark.className = 'search-highlight';
            mark.dataset.matchIndex = part.index;
            mark.textContent = part.content;
            fragment.appendChild(mark);
          }
        });

        parent.replaceChild(fragment, node);
      });
    }

    function clearSearchHighlights() {
      const marks = messagesDiv.querySelectorAll('mark.search-highlight');
      marks.forEach(mark => {
        const parent = mark.parentNode;
        const text = document.createTextNode(mark.textContent);
        parent.replaceChild(text, mark);
        // Normalize to merge adjacent text nodes
        parent.normalize();
      });
    }

    function navigateSearch(direction) {
      if (searchMatches.length === 0) return;

      // Remove current highlight
      const currentMark = messagesDiv.querySelector('mark.search-highlight.current');
      if (currentMark) {
        currentMark.classList.remove('current');
      }

      // Update index
      currentSearchIndex += direction;
      if (currentSearchIndex >= searchMatches.length) {
        currentSearchIndex = 0;
      } else if (currentSearchIndex < 0) {
        currentSearchIndex = searchMatches.length - 1;
      }

      // Update count display
      updateSearchResultsCount(currentSearchIndex + 1, searchMatches.length);

      // Scroll to and highlight current match
      scrollToCurrentMatch();
    }

    function scrollToCurrentMatch() {
      const marks = messagesDiv.querySelectorAll('mark.search-highlight');
      marks.forEach((mark, idx) => {
        const matchIndex = parseInt(mark.dataset.matchIndex);
        if (matchIndex === currentSearchIndex) {
          mark.classList.add('current');
          mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } else {
          mark.classList.remove('current');
        }
      });
    }

    function updateSearchResultsCount(current, total) {
      const countEl = document.getElementById('search-results-count');
      if (total === 0) {
        countEl.textContent = '';
        countEl.classList.remove('has-results');
      } else {
        countEl.textContent = `${current}/${total}`;
        countEl.classList.add('has-results');
      }
    }

    function updateNavButtons() {
      const prevBtn = document.getElementById('search-prev-btn');
      const nextBtn = document.getElementById('search-next-btn');
      const hasMatches = searchMatches.length > 0;

      prevBtn.disabled = !hasMatches;
      nextBtn.disabled = !hasMatches;
    }

    // Keyboard shortcut for search (Cmd/Ctrl + F)
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
        e.preventDefault();
        toggleSearch();
      }
    });

    function showEmptyState() {
      messagesDiv.innerHTML = `
        <div class="empty-state">
          <div class="pixel-heart"></div>
          <div class="empty-title">Franky here!</div>
          <div class="empty-subtitle">ready to go whenever you are, i've got your back </div>
        </div>
      `;
    }

    function scrollToBottom(instant = false) {
      requestAnimationFrame(() => {
        messagesDiv.scrollTo({
          top: messagesDiv.scrollHeight,
          behavior: instant ? 'instant' : 'smooth'
        });
      });
    }

    function scrollToTop() {
      requestAnimationFrame(() => {
        messagesDiv.scrollTo({
          top: 0,
          behavior: 'smooth'
        });
      });
    }

    // Scroll button visibility
    const scrollTopBtn = document.getElementById('scroll-top-btn');
    const scrollBottomBtn = document.getElementById('scroll-bottom-btn');
    const SCROLL_THRESHOLD = 200;

    function updateScrollButtons() {
      const scrollTop = messagesDiv.scrollTop;
      const scrollHeight = messagesDiv.scrollHeight;
      const clientHeight = messagesDiv.clientHeight;
      const distanceFromBottom = scrollHeight - scrollTop - clientHeight;

      // Show "scroll to top" when scrolled down past threshold
      if (scrollTop > SCROLL_THRESHOLD) {
        scrollTopBtn.classList.add('visible');
      } else {
        scrollTopBtn.classList.remove('visible');
      }

      // Show "scroll to bottom" when not at bottom
      if (distanceFromBottom > SCROLL_THRESHOLD) {
        scrollBottomBtn.classList.add('visible');
      } else {
        scrollBottomBtn.classList.remove('visible');
      }
    }

    messagesDiv.addEventListener('scroll', updateScrollButtons);

    function handleKeydown(e) {
      // Tab: Accept the suggestion and place cursor at end
      if (e.key === 'Tab' && getCurrentSuggestion() && !input.value.trim()) {
        e.preventDefault();
        acceptSuggestion();
        return;
      }

      // Enter: Send message (or suggestion if no user input)
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        // If there's a suggestion and no user input, send the suggestion
        if (getCurrentSuggestion() && !input.value.trim()) {
          input.value = getCurrentSuggestion();
          clearSuggestion();
        }
        sendMessage();
        return;
      }

      // Escape: Clear the suggestion
      if (e.key === 'Escape' && getCurrentSuggestion()) {
        e.preventDefault();
        clearSuggestion();
        return;
      }
    }

    function handleInput(e) {
      // When user types, clear the suggestion
      if (getCurrentSuggestion() && input.value.trim()) {
        clearSuggestion();
      }
      autoResizeTextarea();
    }

    function setSuggestion(text) {
      if (!text) {
        clearSuggestion();
        return;
      }
      setCurrentSuggestion(text);
      ghostSuggestion.innerHTML = escapeHtml(text) + '<span class="tab-hint">Tab to accept</span>';
      ghostSuggestion.style.display = 'block';
      input.classList.add('has-suggestion');
    }

    function clearSuggestion() {
      setCurrentSuggestion(null);
      ghostSuggestion.innerHTML = '';
      ghostSuggestion.style.display = 'none';
      input.classList.remove('has-suggestion');
    }

    function acceptSuggestion() {
      if (!getCurrentSuggestion()) return;
      input.value = getCurrentSuggestion();
      clearSuggestion();
      autoResizeTextarea();
      // Place cursor at the end
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);
    }

    function triggerAttach() {
      fileInput.click();
    }

    async function handleFileSelect(e) {
      const files = Array.from(e.target.files);
      if (files.length === 0) return;

      for (const file of files) {
        const ext = file.name.split('.').pop()?.toLowerCase() || '';

        // Validate extension
        if (!ALLOWED_EXTENSIONS.has(ext)) {
          addMessage('system', `Unsupported file type: ${file.name}`);
          continue;
        }

        // Validate size
        if (file.size > MAX_FILE_SIZE) {
          addMessage('system', `File too large (max 10MB): ${file.name}`);
          continue;
        }

        try {
          const attachment = await readFile(file, ext);
          const currentAttachments = getPendingAttachments();
          currentAttachments.push(attachment);
          setPendingAttachments(currentAttachments);
        } catch (err) {
          addMessage('system', `Failed to read file: ${file.name}`);
        }
      }

      // Reset file input and update UI
      fileInput.value = '';
      renderAttachmentPreviews();
      input.focus();
    }

    async function readFile(file, ext) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
          const attachment = {
            name: file.name,
            type: file.type,
            size: file.size,
            ext: ext,
            isImage: IMAGE_EXTENSIONS.has(ext),
          };

          if (attachment.isImage || ext === 'pdf') {
            // Store as data URL for images and PDFs
            attachment.dataUrl = e.target.result;
            attachment.content = null;
          } else {
            // Store as text for text files
            attachment.dataUrl = null;
            attachment.content = e.target.result;
          }

          resolve(attachment);
        };

        reader.onerror = () => reject(reader.error);

        if (IMAGE_EXTENSIONS.has(ext) || ext === 'pdf') {
          reader.readAsDataURL(file);
        } else {
          reader.readAsText(file);
        }
      });
    }

    function renderAttachmentPreviews() {
      // Remove existing container
      const existing = document.querySelector('.attachments-container');
      if (existing) existing.remove();

      const attachments = getPendingAttachments();
      if (attachments.length === 0) return;

      // Create container
      const container = document.createElement('div');
      container.className = 'attachments-container';

      attachments.forEach((att, index) => {
        const preview = document.createElement('div');
        preview.className = 'attachment-preview';

        if (att.isImage && att.dataUrl) {
          const img = document.createElement('img');
          img.src = att.dataUrl;
          img.alt = att.name;
          preview.innerHTML = `
            <div class="attachment-info">
              <div class="attachment-name">${escapeHtml(att.name)}</div>
              <div class="attachment-size">${formatFileSize(att.size)}</div>
            </div>
            <button class="attachment-remove" onclick="playNormalClick(); removeAttachment(${index})"></button>
          `;
          preview.insertBefore(img, preview.firstChild);
        } else {
          preview.innerHTML = `
            <div class="attachment-icon">${att.ext}</div>
            <div class="attachment-info">
              <div class="attachment-name">${escapeHtml(att.name)}</div>
              <div class="attachment-size">${formatFileSize(att.size)}</div>
            </div>
            <button class="attachment-remove" onclick="playNormalClick(); removeAttachment(${index})"></button>
          `;
        }

        container.appendChild(preview);
      });

      // Insert before input area
      const inputArea = document.getElementById('input-area');
      inputArea.parentNode.insertBefore(container, inputArea);
    }

    function removeAttachment(index) {
      const attachments = getPendingAttachments();
      attachments.splice(index, 1);
      setPendingAttachments(attachments);
      renderAttachmentPreviews();
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function clearAttachments() {
      setPendingAttachments([]);
      renderAttachmentPreviews();
    }

    // Drag and Drop handling
    const dragOverlay = document.getElementById('drag-overlay');
    let dragCounter = 0; // Track nested drag events

    function showDragOverlay() {
      dragOverlay.classList.add('active');
    }

    function hideDragOverlay() {
      dragOverlay.classList.remove('active');
    }

    // Prevent default drag behaviors on the whole document
    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter++;

      // Only show overlay if dragging files (types is DOMStringList, use contains not includes)
      if (e.dataTransfer?.types?.contains('Files')) {
        showDragOverlay();
      }
    });

    document.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter--;

      // Hide overlay when drag leaves the window entirely
      if (dragCounter === 0) {
        hideDragOverlay();
      }
    });

    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });

    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter = 0;
      hideDragOverlay();

      const files = Array.from(e.dataTransfer?.files || []);
      if (files.length === 0) return;

      for (const file of files) {
        const ext = file.name.split('.').pop()?.toLowerCase() || '';

        // Validate extension
        if (!ALLOWED_EXTENSIONS.has(ext)) {
          addMessage('system', `Unsupported file type: ${file.name}`);
          continue;
        }

        // Validate size
        if (file.size > MAX_FILE_SIZE) {
          addMessage('system', `File too large (max 10MB): ${file.name}`);
          continue;
        }

        try {
          const attachment = await readFile(file, ext);
          const currentAttachments = getPendingAttachments();
          currentAttachments.push(attachment);
          setPendingAttachments(currentAttachments);
        } catch (err) {
          addMessage('system', `Failed to read file: ${file.name}`);
        }
      }

      renderAttachmentPreviews();
      input.focus();
    });

    // Auto-resize textarea
    input.addEventListener('input', () => {
      input.style.height = 'auto';
      input.style.height = Math.min(input.scrollHeight, 150) + 'px';
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Cmd/Ctrl + K to clear
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        clearChat();
      }
      // Cmd/Ctrl + , to open settings
      if ((e.metaKey || e.ctrlKey) && e.key === ',') {
        e.preventDefault();
        openSettings();
      }
    });

    async function openSettings(tab) {
      try {
        await window.pocketAgent.openSettings(tab);
      } catch (err) {
        console.error('Failed to open settings:', err);
      }
    }

    async function checkForUpdates() {
      try {
        const result = await window.pocketAgent.checkForUpdates();
        const updateBadge = document.getElementById('update-badge');
        if (result.status === 'available' && result.info?.version) {
          updateBadge.textContent = `v${result.info.version}`;
          updateBadge.style.display = 'inline-block';
        } else {
          updateBadge.style.display = 'none';
        }
      } catch (err) {
        // Silently fail - update check is not critical
        console.debug('Update check failed:', err);
      }
    }

    async function openFactsGraph() {
      try {
        await window.pocketAgent.openFactsGraph();
      } catch (err) {
        console.error('Failed to open facts graph:', err);
      }
    }

    async function openCustomize() {
      try {
        await window.pocketAgent.openCustomize();
      } catch (err) {
        console.error('Failed to open customize:', err);
      }
    }

    // Hamburger menu functions
    function toggleMenu() {
      const btn = document.getElementById('hamburger-btn');
      const dropdown = document.getElementById('menu-dropdown');
      const isOpen = dropdown.classList.contains('open');

      if (isOpen) {
        closeMenu();
      } else {
        btn.classList.add('active');
        dropdown.classList.add('open');
      }
    }

    function closeMenu() {
      const btn = document.getElementById('hamburger-btn');
      const dropdown = document.getElementById('menu-dropdown');
      btn.classList.remove('active');
      dropdown.classList.remove('open');
    }

    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
      const menu = document.querySelector('.hamburger-menu');
      if (menu && !menu.contains(e.target)) {
        closeMenu();
      }
    });

    // Close menu on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeMenu();
        closeDailyTasks();
      }
    });

    async function openRoutines() {
      try {
        await window.pocketAgent.openRoutines();
      } catch (err) {
        console.error('Failed to open routines:', err);
      }
    }

    async function openDocs() {
      try {
        await window.pocketAgent.openExternal('https://pocketagent-web.vercel.app/docs');
      } catch (err) {
        console.error('Failed to open docs:', err);
      }
    }

    function openAbout() {
      document.getElementById('about-modal').classList.add('show');
    }

    function closeAbout() {
      document.getElementById('about-modal').classList.remove('show');
    }
  </script>
</body>
</html>
